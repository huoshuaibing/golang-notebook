# 常量

常量的值是在编译器计算，常量值不可更改。  

常量声明和变量一样可以使用分组声明以及单行声明多个。常量声明也存在类型推断。

```
const a, b = 1, 2
const (
	c = 2
	d = 3
)
```

所有常量运算都在编译器完成，这样可以减少运行时的工作，可以提前发现错误等。  

常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof。这些都是在编译器完成的。  

批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。

```
const (
	a = 1
	b
	c = 2
	d
)
fmt.Println(a, b, c, d) // 打印 1 1 2 2
```

未使用的局部常量不会引发编译错误。  

在常量组内，如果不提供类型和初始化值，那么视为和上面的一致。常量组第一个常量必须声明类型或者初始化值。

```
const (
	a = 1
	b
	c = 2
	d
	e
)
fmt.Println(a, b, c, d, e) // 结果为：1 1 2 2 2
```



# iota常量生成器

iota常量生成器通常配合上面提到的常量声明组内可省略的特性来生成一组相似规则的常量。在一个 const 组声明中，第一行时 iota 会被置为 0，以后每行 iota 会加 1。

```
const (
	a = iota
	b
	c
	d
	e
)
fmt.Println(a, b, c, d, e) // 结果为：0 1 2 3 4
```

iota 是跟常量组挂钩的，跟你在哪一行开始声明 iota 无关，第一行的 iota 永远是 0 ，第 i 行使用 iota 的值 为 i - 1。

```
const (
	a = 2
	b = iota
	c
	d
	e
)
fmt.Println(a, b, c, d, e) // 结果为：2 1 2 3 4
```

更复杂的例子（每行后的赋值表达式都是 1 << iota，iota 每行的值会加 1）

```
const (
	a = 1 << iota
	b
	c
	d
	e
)
fmt.Println(a, b, c, d , e) // 结果为：1 2 4 8 16
```

更复杂的例子

```
const (
	a = 1 << (2 * iota)
	b
	c
	d
	e
)
fmt.Println(a, b, c, d , e) // 结果为：1 4 16 64 256
```

Iota 是每行生长的，常量组声明中每行声明多个常量时，它们的 iota 值一样，每行仍然增长 1 。

```
const (
	a,b = iota, iota + 1
	c,d = iota, iota + 2
	e,f = iota, iota + 3
	l = iota * 3
)
fmt.Println(a, b, c, d, e, f, l)  // 输出 0 1 1 3 2 5 9
```



# 无类型常量

Go 语言常量可以声明一个确定的类型，也可以不声明。编译器会为不声明类型的常量提供更高精度算术运算。无类型常量包括：无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。  

无类型的常量的类型是延迟确定的，并可以不用转换直接用于计算，但是当转换的目标类型容不下常量值得时候会报编译错误。

```
g = math.MaxUint64 + math.MaxUint64
fmt.Println(g) // 这里会报错，因为会把常量转化为 int 但是已经超出了 int 的范围
fmt.Println(g/1.0) // 不会报错
```
